-- Trigger para não deixar reservar um horário que ja esteja ocupado

CREATE OR REPLACE FUNCTION agendamento_repetido() RETURNS TRIGGER AS
$$
BEGIN
	IF EXISTS (
		SELECT 1
		FROM agendamento
		WHERE id_quadra = new.id_quadra
			AND status = 'ATIVO'
			AND (
				(new.horario_inicio::time >= horario_inicio::time AND new.horario_inicio::time < horario_fim::time)
				OR (new.horario_fim::time > horario_inicio::time AND new.horario_fim::time <= horario_fim::time)
				OR (new.horario_inicio::time <= horario_inicio::time AND new.horario_fim::time >= horario_inicio::time)
			)
			AND (id_agendamento IS NULL OR id_agendamento != new.id_agendamento)
	) THEN
		RAISE EXCEPTION 'Já existe um agendamento conflitante nessa quadra';
	END IF;
	
	RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER agendamento_repetido BEFORE INSERT OR UPDATE ON agendamento FOR EACH ROW EXECUTE FUNCTION agendamento_repetido();



INSERT INTO Agendamento  VALUES (1, '14:00', '16:00', '2023-05-10', 'Ativo', 10363195980, 1);
INSERT INTO Agendamento  VALUES (2, '15:00', '15:30', '2023-05-10', 'Ativo', 10363195980, 1);
INSERT INTO Agendamento  VALUES (3, '13:00', '15:00', '2023-05-10', 'Ativo', 10363195980, 1);
INSERT INTO Agendamento  VALUES (4, '17:00', '18:00', '2023-05-10', 'Ativo', 10363195980, 1);
select * from agendamento
Delete from agendamento where id_agendamento = 2


insert into bloco values(1,	'aaa', 'aaaa')

insert into quadra values (1, 'A', 'a', 1)



-- Trigger para deixar determinado período reservado para eventos extraordinários

CREATE OR REPLACE FUNCTION evento_extraordinario() RETURNS TRIGGER AS $$
DECLARE
    quadra RECORD;
    agendamento_id INT;
BEGIN
    UPDATE Agendamento SET status = 'CANCELADO' WHERE data = new.data AND (
        (horario_inicio::time <= new.horario_fim::time AND horario_fim::time >= new.horario_inicio::time) OR
        (horario_inicio::time >= new.horario_inicio::time AND horario_inicio::time <= new.horario_fim::time)
    );
    
    FOR quadra IN SELECT * FROM Quadra LOOP
        SELECT nextval('agendamento_id_seq') INTO agendamento_id;
        INSERT INTO Agendamento (id_agendamento, data, horario_inicio, horario_fim, status, cpf, id_quadra)
        VALUES (agendamento_id, new.data, new.horario_inicio, new.horario_fim, 'ATIVO', new.cpf, quadra.id_quadra);
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER evento_extraordinario_trigger AFTER INSERT ON Evento FOR EACH ROW EXECUTE FUNCTION evento_extraordinario();


insert into evento values (8, '2023-05-10', '13:00', '19:00', 'Ativo', 'EVENTO TESTE', 10363195980);
select * from agendamento
drop trigger evento_extraordinario on evento

-- Trigger para ter que possuir 4 dias de antecedencia para marcar um agendamento

CREATE OR REPLACE FUNCTION agendar_antecedencia() RETURNS TRIGGER AS $$
BEGIN
	IF TO_DATE(new.data, 'YYYY-MM-DD') < current_date + INTERVAL '4 days' THEN
		RAISE EXCEPTION 'Agendamento não permitido com menos de 4 dias de antecedência';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER agendar_antecedencia_trigger
BEFORE INSERT ON Agendamento
FOR EACH ROW
EXECUTE FUNCTION agendar_antecedencia();

-- Trigger para não deixar registrar repetido
CREATE OR REPLACE FUNCTION evento_repetido() RETURNS TRIGGER AS
$$
BEGIN
	IF EXISTS (
		SELECT 1
		FROM Evento
		WHERE status = 'ATIVO'
			AND (
				(new.horario_inicio::time >= horario_inicio::time AND new.horario_inicio::time < horario_fim::time)
				OR (new.horario_fim::time > horario_inicio::time AND new.horario_fim::time <= horario_fim::time)
				OR (new.horario_inicio::time <= horario_inicio::time AND new.horario_fim::time >= horario_inicio::time)
			)
			AND (id_evento IS NULL OR id_evento != new.id_evento)
	) THEN
		RAISE EXCEPTION 'Já existe um Evento conflitante nessa quadra';
	END IF;
	
	RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER evento_repetido BEFORE INSERT OR UPDATE ON Evento FOR EACH ROW EXECUTE FUNCTION evento_repetido();

-- Trigger para deletar Bolsistas, Servidores e Responsaveis sempre que deletar um usuario

CREATE OR REPLACE FUNCTION delete_usuario() RETURNS TRIGGER AS 
$$
    BEGIN
        DELETE FROM Bolsista WHERE cpf = OLD.cpf;
        DELETE FROM Servidor WHERE cpf = OLD.cpf;
        DELETE FROM Responsavel WHERE cpf = OLD.cpf;
        RETURN OLD;
    END;
$$ 
LANGUAGE plpgsql;

CREATE TRIGGER delete_usuario AFTER DELETE ON Usuario FOR EACH ROW EXECUTE FUNCTION delete_usuario();


